import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_tts/flutter_tts.dart';

class TTSService {
  static final FlutterTts _flutterTts = FlutterTts();
  static const MethodChannel _audioChannel = MethodChannel('vr_tts_audio');
  static const MethodChannel _nativeTTSChannel = MethodChannel('native_tts');
  static bool _isInitialized = false;
  static bool _isSpeaking = false;
  static bool _useNativeTTS = false;

  static Future<void> initialize() async {
    if (_isInitialized) return;
    
    print("üîÑ Initializing TTS Service for Quest 3S...");
    
    await Future.delayed(Duration(milliseconds: 500));
    
    try {
      bool nativeInitialized = await _nativeTTSChannel.invokeMethod('isInitialized');
      if (nativeInitialized) {
        _useNativeTTS = true;
        print("‚úÖ Using Native Android TTS");
      } else {
        print("‚ö†Ô∏è Native TTS not initialized yet");
        _useNativeTTS = false;
      }
    } catch (e) {
      print("‚ö†Ô∏è Native TTS not available: $e");
      _useNativeTTS = false;
    }
    
    await _flutterTts.setLanguage("vi-VN"); 
    await _flutterTts.setSpeechRate(0.6); 
    await _flutterTts.setVolume(1.0);
    await _flutterTts.setPitch(1.0);
    
    _flutterTts.setStartHandler(() {
      print("üîä Flutter TTS Started");
      _isSpeaking = true;
    });
    
    _flutterTts.setCompletionHandler(() {
      print("üîä Flutter TTS Completed");
      _isSpeaking = false;
    });
    
    _flutterTts.setErrorHandler((msg) {
      print("üö® Flutter TTS Error: $msg");
      _isSpeaking = false;
    });
    
    _flutterTts.setCancelHandler(() {
      print("üîä Flutter TTS Cancelled");
      _isSpeaking = false;
    });
    
    _flutterTts.setPauseHandler(() {
      print("üîä Flutter TTS Paused");
    });
    
    _flutterTts.setContinueHandler(() {
      print("üîä Flutter TTS Continued");
    });
    
    await _configureAudioSession();
    
    _isInitialized = true;
    print("‚úÖ TTS Service initialized for Quest 3S (Native: $_useNativeTTS)");
  }

  static Future<void> speak(String text) async {
    try {
      await initialize();
      
      if (!_isInitialized) {
        print("üö® TTS not initialized, cannot speak");
        return;
      }
      
      if (text.isEmpty) {
        print("‚ö†Ô∏è Empty text provided to TTS");
        return;
      }
      
      if (_isSpeaking) {
        print("‚ö†Ô∏è TTS seems stuck, forcing reset");
        _isSpeaking = false;
        await stop();
      }
      
      print("üîä TTS Speaking: $text (Native: $_useNativeTTS)");
      _isSpeaking = true;
      
      if (_useNativeTTS) {
        await _speakWithNative(text);
      } else {
        await _speakWithFlutter(text);
      }
      
      print("‚úÖ TTS speak command sent");
    } catch (e) {
      print("üö® TTS speak error: $e");
      _isSpeaking = false;
      rethrow;
    }
  }
  
  static Future<void> _speakWithNative(String text) async {
    try {
      bool audioFocusGranted = await _audioChannel.invokeMethod('requestAudioFocus');
      print("üéØ Audio focus granted: $audioFocusGranted");
      
      bool success = await _nativeTTSChannel.invokeMethod('speak', {
        'text': text,
        'language': 'vi-VN'
      });
      
      if (!success) {
        print("‚ö†Ô∏è Native TTS failed, falling back to Flutter TTS");
        await _speakWithFlutter(text);
      } else {
        Future.delayed(Duration(seconds: 3), () {
          _isSpeaking = false;
        });
      }
    } catch (e) {
      print("üö® Native TTS error: $e");
      await _speakWithFlutter(text);
    }
  }
  
  static Future<void> _speakWithFlutter(String text) async {
    try {
      await _audioChannel.invokeMethod('requestAudioFocus');
      
      await _audioChannel.invokeMethod('configureAudioSession');
      
      await _flutterTts.speak(text);
    } catch (e) {
      print("üö® Flutter TTS error: $e");
      _isSpeaking = false;
      rethrow;
    }
  }

  static Future<void> speakDetection(String objectName, double confidence) async {
    String announcement = _createVietnameseAnnouncement(objectName, confidence);
    await speak(announcement);
  }

  static Future<void> speakMultipleDetections(List<Map<String, dynamic>> objects) async {
    if (objects.isEmpty) return;
    
    String announcement = _createMultipleDetectionsAnnouncement(objects);
    await speak(announcement);
  }

  static String _createVietnameseAnnouncement(String objectName, double confidence) {
    String vietnameseName = _translateToVietnamese(objectName);
    
    if (confidence > 0.8) {
      return "T√¥i th·∫•y $vietnameseName";
    } else if (confidence > 0.6) {
      return "C√≥ th·ªÉ l√† $vietnameseName";
    } else {
      return "T√¥i nghƒ© ƒë√¢y l√† $vietnameseName";
    }
  }

  static String _createMultipleDetectionsAnnouncement(List<Map<String, dynamic>> objects) {
    if (objects.length == 1) {
      return _createVietnameseAnnouncement(
        objects[0]['name'] ?? 'v·∫≠t th·ªÉ', 
        objects[0]['confidence'] ?? 0.0
      );
    }

    List<String> vietnameseNames = objects.take(3).map((obj) => 
      _translateToVietnamese(obj['name'] ?? 'v·∫≠t th·ªÉ')
    ).toList();

    if (vietnameseNames.length == 2) {
      return "T√¥i th·∫•y ${vietnameseNames[0]} v√† ${vietnameseNames[1]}";
    } else {
      String result = "T√¥i th·∫•y ";
      for (int i = 0; i < vietnameseNames.length; i++) {
        if (i == vietnameseNames.length - 1) {
          result += "v√† ${vietnameseNames[i]}";
        } else if (i == 0) {
          result += vietnameseNames[i];
        } else {
          result += ", ${vietnameseNames[i]}";
        }
      }
      return result;
    }
  }

  static String _translateToVietnamese(String objectName) {
    if (objectName.isEmpty) return "v·∫≠t th·ªÉ";
    
    String name = objectName.toLowerCase().trim();
    
    final translations = {
      'person': 'ng∆∞·ªùi',
      'people': 'ng∆∞·ªùi',
      'man': 'ƒë√†n √¥ng',
      'woman': 'ph·ª• n·ªØ',
      'child': 'tr·∫ª em',
      'baby': 'em b√©',
      
      'chair': 'gh·∫ø',
      'table': 'b√†n',
      'bed': 'gi∆∞·ªùng',
      'sofa': 'sofa',
      'desk': 'b√†n l√†m vi·ªác',
      'shelf': 'k·ªá',
      'couch': 'gh·∫ø sofa',
      
      'tv': 'tivi',
      'television': 'tivi',
      'computer': 'm√°y t√≠nh',
      'laptop': 'laptop',
      'phone': 'ƒëi·ªán tho·∫°i',
      'mobile': 'ƒëi·ªán tho·∫°i di ƒë·ªông',
      'tablet': 'm√°y t√≠nh b·∫£ng',
      'monitor': 'm√†n h√¨nh',
      'keyboard': 'b√†n ph√≠m',
      'mouse': 'chu·ªôt',
      'remote': 'ƒëi·ªÅu khi·ªÉn t·ª´ xa',
      
      'bottle': 'chai',
      'cup': 'c·ªëc',
      'glass': 'ly',
      'bowl': 'b√°t',
      'plate': 'ƒëƒ©a',
      'spoon': 'th√¨a',
      'fork': 'nƒ©a',
      'knife': 'dao',
      
      'apple': 't√°o',
      'banana': 'chu·ªëi',
      'orange': 'cam',
      'bread': 'b√°nh m√¨',
      'cake': 'b√°nh ng·ªçt',
      'pizza': 'pizza',
      'water': 'n∆∞·ªõc',
      'coffee': 'c√† ph√™',
      'tea': 'tr√†',
      'milk': 's·ªØa',
      'juice': 'n∆∞·ªõc √©p',
      
      'car': '√¥ t√¥',
      'bus': 'xe bu√Ωt',
      'truck': 'xe t·∫£i',
      'bike': 'xe ƒë·∫°p',
      'bicycle': 'xe ƒë·∫°p',
      'motorcycle': 'xe m√°y',
      
      'cat': 'm√®o',
      'dog': 'ch√≥',
      'bird': 'chim',
      'fish': 'c√°',
      
      'shirt': '√°o s∆° mi',
      'pants': 'qu·∫ßn',
      'shoes': 'gi√†y',
      'hat': 'm≈©',
      'bag': 't√∫i',
      'backpack': 'ba l√¥',
      'watch': 'ƒë·ªìng h·ªì',
      'glasses': 'k√≠nh',
      
      'door': 'c·ª≠a',
      'window': 'c·ª≠a s·ªï',
      'wall': 't∆∞·ªùng',
      'ceiling': 'tr·∫ßn nh√†',
      'floor': 's√†n nh√†',
      'stairs': 'c·∫ßu thang',
      'light': 'ƒë√®n',
      'lamp': 'ƒë√®n b√†n',
      
      'book': 's√°ch',
      'pen': 'b√∫t',
      'pencil': 'b√∫t ch√¨',
      'paper': 'gi·∫•y',
      'notebook': 'v·ªü',
    };
    
    return translations[name] ?? name;
  }

  static Future<void> stop() async {
    await _flutterTts.stop();
    _isSpeaking = false;
  }

  static Future<void> pause() async {
    await _flutterTts.pause();
  }

  static bool get isSpeaking => _isSpeaking;
  static bool get isInitialized => _isInitialized;

  static Future<void> speakWithFallback(String text, BuildContext? context) async {
    try {
      await speak(text);
    } catch (e) {
      print("üö® TTS Error: $e");
      if (context != null) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(text),
            duration: Duration(seconds: 3),
          )
        );
      }
    }
  }

  static Future<void> _configureAudioSession() async {
    try {
      await _audioChannel.invokeMethod('configureAudioSession');
      print("‚úÖ Audio session configured for Quest VR");
    } catch (e) {
      print("‚ö†Ô∏è Could not configure audio session: $e");
    }
  }
  
  static Future<Map<String, dynamic>?> testAudioSystem() async {
    try {
      Map<dynamic, dynamic> result = await _audioChannel.invokeMethod('testAudio');
      print("üîç Audio test result: $result");
      return Map<String, dynamic>.from(result);
    } catch (e) {
      print("üö® Audio test failed: $e");
      return null;
    }
  }

  static Future<void> setOptimalVoiceForQuest() async {
    await initialize();
    
    try {
      List<Map> voices = await _flutterTts.getVoices;
      print("üì¢ Available voices: ${voices.length}");
      
      Map? bestVietnameseVoice;
      Map? fallbackVoice;
      
      for (var voice in voices) {
        String locale = voice['locale'] ?? '';
        String name = voice['name'] ?? '';
        
        if (locale.startsWith('vi')) {
          bestVietnameseVoice = voice;
          break;
        } else if (locale.startsWith('en') && fallbackVoice == null) {
          fallbackVoice = voice;
        }
      }
      
      if (bestVietnameseVoice != null) {
        await _flutterTts.setVoice(Map<String, String>.from(bestVietnameseVoice));
        print("‚úÖ Set Vietnamese voice: ${bestVietnameseVoice['name']}");
      } else if (fallbackVoice != null) {
        await _flutterTts.setVoice(Map<String, String>.from(fallbackVoice));
        print("‚ö†Ô∏è Using fallback English voice: ${fallbackVoice['name']}");
      }
    } catch (e) {
      print("‚ö†Ô∏è Could not set specific voice: $e");
    }
  }
  
  static Future<void> testNativeTTS(String text) async {
    try {
      await initialize();
      print("üß™ Testing Native TTS...");
      
      bool success = await _nativeTTSChannel.invokeMethod('speak', {
        'text': text,
        'language': 'vi-VN'
      });
      
      print("üß™ Native TTS test result: $success");
    } catch (e) {
      print("üö® Native TTS test error: $e");
    }
  }
  
  static Future<void> forceReset() async {
    try {
      print("üîÑ Force resetting TTS...");
      _isSpeaking = false;
      await _flutterTts.stop();
      await _nativeTTSChannel.invokeMethod('stop');
      print("‚úÖ TTS force reset completed");
    } catch (e) {
      print("‚ö†Ô∏è TTS force reset error: $e");
    }
  }
  
  static Future<void> testSimpleBeep() async {
    try {
      print("üîî Testing simple beep...");
      await _audioChannel.invokeMethod('playBeep');
      print("‚úÖ Beep test completed");
    } catch (e) {
      print("üö® Simple beep test error: $e");
    }
  }
  
  static Future<void> testTone() async {
    try {
      print("üéµ Testing tone sound...");
      await _audioChannel.invokeMethod('playTone');
      print("‚úÖ Tone test completed");
    } catch (e) {
      print("üö® Tone test error: $e");
    }
  }
}